# Прогресс работы над заданием "Используем ООП в Арканоиде"

## Общее описание задания
Перевести оставшиеся структуры на классы с использованием инкапсуляции, реализовать RAII для GameState, создать классы Paddle (платформа) и Ball (шарик).

---

## ✅ Пункт 1: Перевести оставшиеся структуры на классы

### 1.1. MenuState struct → class ✅
**Статус:** Выполнено

**Изменения:**
- `struct MenuState` преобразована в `class MenuState`
- Все поля перенесены в `private` секцию
- Добавлены getters (все с `const`):
  - `getSoundEnabled()`, `getMusicEnabled()`, `getSelectedIndex()`
  - `getV()`, `getP()`, `getL()`, `getT()`, `getDifficultyLevel()`
- Добавлены setters:
  - `setSoundEnabled()`, `setMusicEnabled()`, `setSelectedIndex()`
  - `setV()`, `setP()`, `setL()`, `setT()`, `setDifficultyLevel()`
- Добавлен конструктор по умолчанию: `MenuState() = default;`
- Все обращения к полям заменены на getters/setters во всех файлах проекта

**Файлы:**
- `SnakeGame/UI.h` - определение класса
- `SnakeGame/UI.cpp` - все обращения заменены
- `SnakeGame/GameMain.cpp` - все обращения заменены
- `SnakeGame/SoundManager.cpp` - все обращения заменены

---

### 1.2. HighScoreEntry struct → class ✅
**Статус:** Выполнено

**Изменения:**
- `struct HighScoreEntry` преобразована в `class HighScoreEntry`
- Поля `playerName` и `score` перенесены в `private` секцию
- Добавлен конструктор с параметрами и значениями по умолчанию:
  ```cpp
  HighScoreEntry(const std::string& name = "", int scoreValue = 0)
      : playerName(name), score(scoreValue)
  ```
- Добавлены getters (с `const`): `getPlayerName()`, `getScore()`
- Добавлены setters: `setPlayerName()`, `setScore()`
- Все обращения к полям заменены на getters/setters

**Файлы:**
- `SnakeGame/HighScoreManager.h` - определение класса
- `SnakeGame/HighScoreManager.cpp` - все обращения заменены
- `SnakeGame/UI.cpp` - все обращения заменены

---

### 1.3. MenuItem struct
**Статус:** Оставлено как struct (одно поле text, преобразование не требуется)

---

## ✅ Пункт 2: GameState с RAII

**Статус:** Выполнено

**Изменения:**
- Создан класс `GameStateManager` для управления состоянием игры
- Реализована идиома RAII:
  - Конструктор инициализирует `currentState = GameState::MENU`
  - Деструктор по умолчанию (автоматическая очистка)
- Приватное поле: `GameState currentState`
- Публичные методы:
  - `GameState getCurrentState() const` - получение текущего состояния
  - `void setState(GameState newState)` - установка нового состояния
- Глобальная переменная `enum class GameState gameState` заменена на объект `GameStateManager gameStateManager`
- Все обращения к `gameState` заменены на `gameStateManager.getCurrentState()` и `gameStateManager.setState()`

**Файлы:**
- `SnakeGame/GameStateManager.h` - новый файл, определение класса
- `SnakeGame/GameMain.cpp` - определение глобального объекта, все обращения заменены
- `SnakeGame/Snake.cpp` - все обращения заменены
- `SnakeGame/UI.cpp` - все обращения заменены
- `SnakeGame/Constants.h` - удалено `extern GameState gameState;`
- `SnakeGame/SnakeGame.vcxproj` - добавлен новый файл в проект
- `SnakeGame/SnakeGame.vcxproj.filters` - добавлен новый файл в проект

---

## ✅ Пункт 3: Класс Paddle (платформа)

**Статус:** Выполнено

**Требования:**
- ✅ Платформа представляет собой прямоугольник
- ✅ Управление стрелочками клавиатуры (влево/вправо)
- ✅ Управление мышью (платформа следует за курсором)
- ✅ Платформа находится внизу игрового поля
- ✅ Движение только влево/вправо

**Реализация:**

**Класс Paddle:**
- **Приватные поля:**
  - `sf::RectangleShape shape` - форма ракетки (прямоугольник)
  - `float width` - ширина ракетки в пикселях (3 клетки)
  - `float height` - высота ракетки в пикселях (1 клетка)
  - `float speed` - скорость движения в пикселях/секунду (200.0f)
  - `sf::Vector2f position` - позиция ракетки в пикселях
- **Публичные методы:**
  - `Paddle()` - конструктор с инициализационным списком
  - `void update(float deltaTime, const sf::RenderWindow& window)` - обновление состояния (обработка ввода, движение)
  - `void draw(sf::RenderWindow& window)` - отрисовка (объявлен, реализация будет в пункте 4)
  - `sf::Vector2f getPosition() const` - получение позиции (объявлен, реализация будет в пункте 4)
  - `sf::Vector2f getSize() const` - получение размеров (объявлен, реализация будет в пункте 4)
  - `sf::FloatRect getBounds() const` - получение границ для коллизий (объявлен, реализация будет в пункте 4)
- **Приватные методы:**
  - `void initializeShape()` - инициализация формы ракетки

**Особенности реализации:**
- Конструктор инициализирует все поля через инициализационный список
- Позиция платформы: внизу экрана по центру
- Управление мышью имеет приоритет (если мышь в окне, используется мышь, иначе клавиатура)
- Ограничение движения границами экрана
- Frame-rate independent движение (используется deltaTime)

**Файлы:**
- `SnakeGame/Paddle.h` - новый файл, определение класса
- `SnakeGame/Paddle.cpp` - новый файл, реализация конструктора, initializeShape(), update()
- `SnakeGame/SnakeGame.vcxproj` - добавлены новые файлы в проект
- `SnakeGame/SnakeGame.vcxproj.filters` - добавлены новые файлы в проект

**Примечания:**
- Размеры платформы: 3 клетки ширины × 1 клетка высоты
- Скорость: 200 пикселей/секунду (базовая, можно увеличивать для сложности)
- Использован существующий `enum class Direction` (LEFT, RIGHT для клавиатуры)
- Все данные инкапсулированы внутри класса (принципы ООП)

---

## ✅ Пункт 4: Класс Ball (шарик)

**Статус:** Выполнено (на текущем этапе)

**Требования:**
- Создать класс Ball для шарика
- Шарик должен летать и отталкиваться от платформы
- Шарик должен отталкиваться от стенок экрана

**Реализация:**
- **Приватные поля:**
  - `sf::CircleShape shape` - форма шарика (круг)
  - `float radius` - радиус шарика в пикселях (1 клетка)
  - `float speed` - скорость движения шарика в пикселях/секунду (300.0f)
  - `sf::Vector2f position` - позиция шарика в пикселях
  - `sf::Vector2f velocity` - вектор скорости шарика (направление и скорость, начальное направление: 60° от горизонтали вверх-вправо)
- **Публичные методы:**
  - `Ball()` - конструктор с инициализационным списком
  - `void update(float deltaTime)` - обновление состояния (базовое движение реализовано)
  - `void draw(sf::RenderWindow& window)` - отрисовка шарика (объявлен, реализация отложена)
  - `sf::Vector2f getPosition() const` - получение позиции (inline, реализован)
  - `sf::FloatRect getBounds() const` - получение границ для коллизий (inline, реализован)
- **Приватные методы:**
  - `void initializeShape()` - инициализация формы шарика (реализован)

**Особенности реализации:**
- Конструктор инициализирует все поля через инициализационный список
- Начальная позиция: центр экрана по X, на платформе по Y (касается окружностью)
- Начальная скорость: 300 пикселей/секунду под углом 60° от горизонтали
- Frame-rate independent движение (используется deltaTime)
- Все данные инкапсулированы внутри класса (принципы ООП)

**Файлы:**
- `SnakeGame/Ball.h` - новый файл, определение класса
- `SnakeGame/Ball.cpp` - новый файл, реализация конструктора, initializeShape(), update()
- `SnakeGame/SnakeGame.vcxproj` - добавлены новые файлы в проект
- `SnakeGame/SnakeGame.vcxproj.filters` - добавлены новые файлы в проект

**Примечания:**
- **Прилипание шарика к платформе:** В классическом Арканоиде шарик прилеплен к платформе при старте и запускается по нажатию пробела. В текущем задании этого требования нет, поэтому реализован упрощенный вариант: шарик сразу начинает движение при инициализации. В будущем, если потребуется добавить функционал прилипания, можно будет легко расширить класс, добавив:
  - Поле состояния `bool isAttached`
  - Метод `attachToPaddle()` для прилипания к платформе
  - Метод `launch()` для запуска шарика по нажатию пробела
  - Проверку состояния в методе `update()`
- **Проверка столкновений:** Решено, что проверка столкновений шарика с различными объектами (стенки экрана, платформа, блоки) будет происходить **глобально, в игровом цикле** (GameMain.cpp или Game.cpp), а не внутри класса Ball. Причины:
  - Шарик сталкивается с разными типами объектов (стенки, платформа, будущие блоки)
  - Если делать проверку внутри класса Ball, пришлось бы добавлять логику для каждого типа объекта, что усложнит класс и нарушит принцип единственной ответственности
  - В игровом цикле есть доступ ко всем объектам игры, что позволяет централизовать проверку коллизий
  - Класс Ball отвечает только за движение (обновление позиции на основе velocity) и предоставляет методы для получения границ (`getBounds()`) и изменения направления (`bounceHorizontal()`, `bounceVertical()`)
  - Пример использования: в игровом цикле проверяем `ball.getBounds().intersects(paddle.getBounds())` и вызываем соответствующий метод отскока

---

## Примечания

- Все изменения соответствуют принципам ООП (инкапсуляция, RAII)
- Использованы инициализационные списки в конструкторах где возможно
- Все getters помечены как `const`
- Код компилируется без ошибок после каждого пункта
- Проект структурирован и готов к дальнейшей работе

---

## Следующие шаги

1. ✅ Реализовать пункт 4 (класс Ball) - ВЫПОЛНЕНО
2. Реализовать метод draw() для Ball (когда потребуется отрисовка)
3. Реализовать проверку столкновений и отскоки (когда будут все объекты - блоки, стенки)
4. Закоммитить все изменения в GitHub одним коммитом
5. Отправить ссылку на коммит для проверки куратору

